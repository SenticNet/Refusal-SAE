FUNCTION: linear_attribution :  
- steering_vec is the refusal direction. interpolate_steps is doing Integrated Gradients (IG)

- computes patch features (what is the value the feat would have taken if the activations were orthogonalized with the direction) - This is a trick to get patch state that is of similar seq length. Past literature does so by editing the input token, we do so in activation space. Imagine 2 models: model A jailbreaks, model B don't. By using the activations of A as patch, we are measuring the attribution values of each feature in B through the increase in jailbreak behavior when the feature is pushed towards A (clean = B, corrupt = A).

-IG: if 10 steps , higher steps use more VRAM, normal is 10steps. If using IG, break up the ds in batches

- Output: attr,grad,delta. grad and delta for edges computation, attribution is the value of each feat, use a threshold to select = dict key = layer , v = 3D tensor (B,CTX,d_feat)

-** TAKE NOTE: the sequences are padded, so if we want to take 1st sample, and look at seq level, we need to pad the corresponding sample OR just use circuit_tolist function (see below).

------------------------------------------------------------------------------------------
 
FUNCTION: create_circuit_mask : 

- given a threshold, attributions derive from linear_attribution, and a clamp_val (optional) and topk_feat (to do 2nd stage filtering) - output the thresholded node features, similar structure as attributions

- positions responding to 0 is the feat, while 1 means not. (set as such so that we can directly multiply the features to simulate clamping using clamp_sae_mask function )

- if clamp value is given, set the pos = 0 to the clamp val 

------------------------------------------------------------------------------------------

FUNCTION: topk_match_mask : given a thresholded feat circuit and attribution values, create a new circuit to replicate the first circuit but by selecting equal amounts of features using the values from attribution (take top). So if 1st circuit has 2 tokens and token 1 has 10 feat, 2 has 5, the new circuit sorts the feat values first, then select top 10 for token 1, 5 for 2.

------------------------------------------------------------------------------------------

FUNCTION: clamp_circuit_to_value: given circuit, true_val is positions whose val you want to clamp and clamp value - set those position to clamp value


------------------------------------------------------------------------------------------

FUNCTION: get_edges: Look at the paper and jvp function from https://github.com/saprmarks/feature-circuits/blob/main/attribution.py

------------------------------------------------------------------------------------------

FUNCTION: ablate_hook/clamp_sae_mask is the main function for direction ablation / individual sample/seq sae clamping. If don't care about pos/sample, just use clamp_sae function (give features and it just clamps across all seq, pos)

------------------------------------------------------------------------------------------
FUNCTION: get_steering_vec : given harmless/harmful ds - get steer vec : dict: layer:vec

------------------------------------------------------------------------------------------
FUNCTION: topk_feat_sim: get topk cosine features per layer.

------------------------------------------------------------------------------------------
FUNCTION: get_sae_feat_val: get sae features for a dataset

------------------------------------------------------------------------------------------
FUNCTION: get_circuit_act_diff: given 2 topk features (dict : k = layer, values = list of feature), take difference between the two. It is signed, unless abs = True.

------------------------------------------------------------------------------------------
FUNCTION: patchscope: perform patchscope on a feature by setting the feat vec to the last layer residual

------------------------------------------------------------------------------------------
FUNCTION: circuit_tolist: 

- given the threshold circuit which is a dict of key = layers and values is 3D tensor (B,CTX,d_feat), output a nested list where 1st list is batch size, 2nd is seq and each seq contains a list of tuples (layer ,feat), makes it easier when doing individual sample/token analysis.

- if given input_ids and removing_padding = True, ignores the padded positions for input/circuit. 

-ignore_bos is True = ignore bos features (found that this doesnt affect behavior much and features are more relevant.)

------------------------------------------------------------------------------------------
Look at eval_refusal.py for eval methods






